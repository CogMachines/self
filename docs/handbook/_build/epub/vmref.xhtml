<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>8. Virtual Machine Reference</title>
    
    <link rel="stylesheet" href="_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" /> 
  </head>
  <body role="document">

    <div class="document">
      <div class="documentwrapper">
          <div class="body" role="main">
            
  <div class="section" id="virtual-machine-reference">
<span id="pp-vmref"></span><h1>8. Virtual Machine Reference</h1>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="buildvm.xhtml">8.1. Building a VM</a><ul>
<li class="toctree-l2"><a class="reference internal" href="buildvm.xhtml#requirements">8.1.1. Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="buildvm.xhtml#building">8.1.2. Building</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="startup-options">
<h2>8.2. Startup options</h2>
<p>The following command-line options are recognised by the Virtual Machine:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">-f</span> <span class="pre">filename</span></code></td>
<td>Reads filename (which should contain Self source) immediately after startup (after reading the snapshot) and evaluates the contents. Useful for setting options, installing personal shortcuts, etc.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">-h</span></code></td>
<td>Prints a message describing the options.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">-p</span></code></td>
<td>Suppresses execution of the expression <code class="docutils literal"><span class="pre">snapshotAction</span> <span class="pre">postRead</span></code> after reading a snapshot. Useful if something in the startup sequence causes the system to break.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">-s</span> <span class="pre">snapshot</span></code></td>
<td>Reads initial world from snapshot. A snapshot begins with the line <code class="docutils literal"><span class="pre">exec</span> <span class="pre">Self</span> <span class="pre">-s</span> <span class="pre">$0</span> <span class="pre">$&#64;</span></code> which causes the Virtual Machine to begin execution with the snapshot.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">-w</span></code></td>
<td>Don’t print warnings about object code.</td>
</tr>
</tbody>
</table>
<p>These options are provided for use by Self VM implementors:</p>
<table border="1" class="colwidths-given docutils">
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Argument</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">-F</span></code></td>
<td>Discards any machine code saved in the snapshot. If the code in a snapshot is for some reason corrupted, but the objects are not, this option can be used to recover the snapshot.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">-l</span> <span class="pre">logfile</span></code></td>
<td>Writes a log of events generated by the spy to logfile.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">-r</span></code></td>
<td>Disables real timer interrupts.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">-t</span></code></td>
<td>Disables all timers.</td>
</tr>
</tbody>
</table>
<p>Other command-line options are ignored by the Virtual Machine but are available at Self level via
the primitive <code class="docutils literal"><span class="pre">_CommandLine</span></code>.</p>
<p>The standard set of Self objects (built by the <code class="docutils literal"><span class="pre">worldBuilder.self</span></code> script) also defines <code class="docutils literal"><span class="pre">-b</span></code> (where the <code class="docutils literal"><span class="pre">objects</span></code> director is) and <code class="docutils literal"><span class="pre">-o</span></code> (for specifying build options)</p>
</div>
<div class="section" id="system-triggered-messages">
<h2>8.3. System-triggered messages</h2>
<p>Certain events cause the system to automatically send a message to the lobby. After reading a snapshot
the expression <code class="docutils literal"><span class="pre">snapshotAction</span> <span class="pre">postRead</span></code> is evaluated. This allows the Self world to
reinitialize itself — for example, to reopen windows.</p>
<p>There are other situations in which the system sends messages; see <a class="reference internal" href="#run-time-message-lookup-errors">Run-time message lookup errors</a>.</p>
<span class="target" id="index-0"></span><span class="target" id="index-1"></span><span class="target" id="index-2"></span><span class="target" id="index-3"></span><span class="target" id="index-4"></span><span class="target" id="index-5"></span></div>
<div class="section" id="run-time-message-lookup-errors">
<span id="index-6"></span><h2>8.4. Run-time message lookup errors</h2>
<p>If an error occurs during a message send, the system sends a message to the receiver of the message.
Any object can handle these errors by defining (or inheriting) a slot with the corresponding
selector. All messages sent by the system in response to a message lookup error have the same arguments.
The first argument is the offending message’s selector; the additional arguments specify
the message send type (one of ’<code class="docutils literal"><span class="pre">normal</span></code>’, ’<code class="docutils literal"><span class="pre">implicitSelf</span></code>’, ’<code class="docutils literal"><span class="pre">undirectedResend</span></code>’, ’<code class="docutils literal"><span class="pre">directedResend</span></code>’,
or ’<code class="docutils literal"><span class="pre">delegated</span></code>’), the directed resend parent name or the delegatee (0 if not
applicable), the sending method holder, and a vector containing the arguments to the message, if
any.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">undefinedSelector:Type:Delegatee:MethodHolder:Arguments</span></code></dt>
<dd><div class="first last line-block">
<div class="line">The receiver does not understand the <code class="docutils literal"><span class="pre">message:</span></code> no slot matching the selector can be found in the receiver or its ancestors.</div>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">ambiguousSelector:Type:Delegatee:MethodHolder:Arguments</span></code></dt>
<dd><div class="first last line-block">
<div class="line">There is more than one slot matching the selector.</div>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">missingParentSelector:Type:Delegatee:MethodHolder:Arguments</span></code></dt>
<dd><div class="first last line-block">
<div class="line">The parent slot through which the resend should have been directed was not found in the sending method holder.</div>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">mismatchedArgumentCountSelector:Type:Delegatee:MethodHolder:Arguments</span></code></dt>
<dd><div class="first last line-block">
<div class="line">The number of arguments supplied to the <code class="docutils literal"><span class="pre">_Perform</span></code> primitive does not match the number of arguments required by the selector.</div>
</div>
</dd>
<dt><code class="docutils literal"><span class="pre">performTypeErrorSelector:Type:Delegatee:MethodHolder:Arguments</span></code></dt>
<dd><div class="first last line-block">
<div class="line">The first argument to the <code class="docutils literal"><span class="pre">_Perform</span></code> primitive (the selector) wasn’t a canonical string.</div>
</div>
</dd>
</dl>
<p>These error messages are just like any other message. Therefore, it is possible that the object P
causing the error (which is being sent the appropriate error message) does not understand the error
message <em>M</em> either. If this happens, the system sends the first message (<code class="docutils literal"><span class="pre">undefinedSelector:</span></code>) to
the current process, with the error message M as argument. If this is not understood, then the system
suspends the process. If the scheduler is running, it is notified of the failure.</p>
<p>The system will also suspend a process if it runs out of stack space (too much recursion) or if a
block is evaluated whose lexically-enclosing scope has already returned. Since these errors are
nonrecoverable they cannot be caught by the same Self process; the scheduler, if running, is notified.</p>
</div>
<div class="section" id="low-level-error-messages">
<h2>8.5. Low-level error messages</h2>
<p>Five kinds of errors can occur during the execution of a Self program: lookup errors, primitive errors,
programmer defined errors, non-recoverable errors, and fatal VM errors. All but the last of
these are usually caught and handled by mechanisms in the programming environment, resulting
in a debugger being presented to the user. However, if programs are run without the programming
environment, or the error-handling mechanisms themselves are broken, low-level error facilities
are used.</p>
<p>This section describes the various error messages presented by the low-level facilities. For each
category or error, the general layout of error messages in that category will be explained along with
the format of the stack trace. Then a “rogue’s gallery” of the errors in that category will be shown.</p>
<p>By default, errors are handled by a set of methods defined in module <code class="docutils literal"><span class="pre">errorHandling</span></code>. For all errors
except nonrecoverable and fatal VM errors, an object can handle errors in its own way by defining
its own error handling methods. If the object in which an error occurs neither inherits nor
defines error handling behavior, the VM prints out a low-level error message and a stack trace. The
system will also resort to this low-level message and trace if an error is encountered while trying
to handle an error.</p>
</div>
<div class="section" id="an-example">
<h2>8.6. An example</h2>
<p>Here is an expression that produces an error in the current system:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>“Self 7” 100000 factorial
The stack has grown too big.
(Self limits stack sizes, and cannot resume processes with stack overflows.)
To debug type “attach” or to show stack type “zombies first printError”.
</pre></div>
</div>
<p>The error arose because the recursive method factorial exceeded the size allocated for the process
stack which resulted in a stack overflow.</p>
<p>The virtual machine currently allocates a fixed-size stack to each process and does not extend the stack on demand.</p>
</div>
<div class="section" id="lookup-errors">
<h2>8.7. Lookup errors</h2>
<p>Lookup errors occur when an object does not understand a message that is sent to it. How the actual
message lookup is done is described in the <a class="reference internal" href="langref.xhtml"><span class="doc">Language Reference</span></a> chapter.</p>
<dl class="docutils">
<dt><strong>No ’foo’ slot found in shell &lt;0&gt;.</strong></dt>
<dd><div class="first last line-block">
<div class="line">The lookup found no slot matching the selector <code class="docutils literal"><span class="pre">foo</span></code>.</div>
</div>
</dd>
<dt><strong>No ’fish’ delegatee slot was found in &lt;a child of lobby&gt; &lt;12&gt;.</strong></dt>
<dd><div class="first last line-block">
<div class="line">The lookup found no parent slot <code class="docutils literal"><span class="pre">fish</span></code>, which was explicitly specified as the delegatee of the message.</div>
</div>
</dd>
</dl>
<div class="line-block">
<div class="line"><strong>More than one ’system’ slot was found in shell &lt;0&gt;.</strong></div>
<div class="line"><strong>The matching slots are: oddballs &lt;6&gt; and prototypes &lt;7&gt;.</strong></div>
</div>
<blockquote>
<div><div class="line-block">
<div class="line">The lookup found two matching <code class="docutils literal"><span class="pre">system</span></code> slots which means the message is ambiguous. The error message also says where the matching slots were found.</div>
</div>
</div></blockquote>
</div>
<div class="section" id="programmer-defined-errors">
<h2>8.8. Programmer defined errors</h2>
<p>These are explicitly raised in the Self program to report errors, e.g. sending the message <code class="docutils literal"><span class="pre">first</span></code>
to an empty list will cause such an error.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Error</span><span class="p">:</span> <span class="n">first</span> <span class="ow">is</span> <span class="n">absent</span><span class="o">.</span>
<span class="n">Receiver</span> <span class="ow">is</span><span class="p">:</span> <span class="nb">list</span> <span class="o">&lt;</span><span class="mi">7</span><span class="o">&gt;.</span>
</pre></div>
</div>
<p>Use the selectors <code class="docutils literal"><span class="pre">error:</span></code> and <code class="docutils literal"><span class="pre">error:Arguments:</span></code> to raise a programmer defined error.</p>
</div>
<div class="section" id="primitive-errors">
<h2>8.9. Primitive errors</h2>
<p>Primitive failures occur when a primitive cannot perform the requested operation, for example, because
of a missing or invalid argument.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>badTypeError: the ’_IntAdd:’ primitive failed.
Its receiver was shell &lt;6&gt;.
</pre></div>
</div>
<blockquote>
<div>The primitive failed with <code class="docutils literal"><span class="pre">badTypeError</span></code> because the shell in not an integer.</div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">selector</span> <span class="mi">12</span> <span class="n">could</span> <span class="ow">not</span> <span class="n">be</span> <span class="n">sent</span> <span class="n">to</span> <span class="n">shell</span> <span class="n">because</span> <span class="n">it</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">a</span> <span class="n">string</span><span class="o">.</span>
</pre></div>
</div>
<blockquote>
<div>The primitive <code class="docutils literal"><span class="pre">_Perform</span></code> expects a string as its first argument.</div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span>The selector ’add:’ could not be sent to shell &lt;0&gt; because it does not take 2 arguments.
</pre></div>
</div>
<blockquote>
<div>The primitive <code class="docutils literal"><span class="pre">_Perform</span></code> received the wrong number of arguments.</div></blockquote>
<p>There are many other kinds of possible primitive errors.</p>
</div>
<div class="section" id="nonrecoverable-process-errors">
<h2>8.10. Nonrecoverable process errors</h2>
<p>Errors that stop a process from continuing execution are referred to as nonrecoverable errors.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">stack</span> <span class="n">has</span> <span class="n">grown</span> <span class="n">too</span> <span class="n">big</span><span class="o">.</span>
<span class="p">(</span><span class="n">Self</span> <span class="mf">4.0</span> <span class="n">limits</span> <span class="n">stack</span> <span class="n">sizes</span><span class="p">,</span> <span class="ow">and</span> <span class="n">cannot</span> <span class="n">resume</span> <span class="n">processes</span> <span class="k">with</span> <span class="n">stack</span>
<span class="n">overflows</span><span class="o">.</span><span class="p">)</span>
</pre></div>
</div>
<blockquote>
<div>A stack overflow error occurs because the current version of Self allocates a fixed size stack for each process, and the stack cannot be expanded.</div></blockquote>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">Self</span> <span class="mf">4.0</span> <span class="n">cannot</span> <span class="n">run</span> <span class="n">a</span> <span class="n">block</span> <span class="n">after</span> <span class="n">its</span> <span class="n">enclosing</span> <span class="n">method</span> <span class="n">has</span> <span class="n">returned</span><span class="o">.</span>
<span class="p">(</span><span class="n">Self</span> <span class="n">cannot</span> <span class="n">resume</span> <span class="n">this</span> <span class="n">process</span><span class="p">,</span> <span class="n">either</span><span class="o">.</span><span class="p">)</span>
</pre></div>
</div>
<blockquote>
<div>This error occurs if a block is executed after its lexically enclosing method has returned.
This is called a “non-LIFO” block. Non-LIFO blocks are not supported by
the current version of Self.</div></blockquote>
</div>
<div class="section" id="fatal-errors">
<span id="index-7"></span><h2>8.11. Fatal errors</h2>
<p>In rare cases, the virtual machine may encounter a fatal error (e.g., a resource limit is exceeded or
an internal error is discovered). When this happens, a short menu is displayed:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">VM</span> <span class="n">Version</span><span class="p">:</span> <span class="mf">4.0</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">Tue</span> <span class="mi">27</span> <span class="n">Jun</span> <span class="mi">95</span> <span class="mi">13</span><span class="p">:</span><span class="mi">35</span><span class="p">:</span><span class="mi">49</span> <span class="n">Solaris</span> <span class="mf">2.</span><span class="n">x</span> <span class="p">(</span><span class="n">svr4</span><span class="p">)</span>
<span class="n">Internal</span> <span class="n">error</span><span class="p">:</span> <span class="n">signal</span> <span class="mi">11</span> <span class="n">code</span> <span class="mi">3</span> <span class="n">addr</span> <span class="mi">4</span> <span class="n">pc</span> <span class="mh">0x1ac768</span><span class="o">.</span>
<span class="n">Do</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span><span class="p">:</span>
<span class="mi">1</span><span class="p">)</span> <span class="n">Quit</span> <span class="n">Self</span> <span class="p">(</span><span class="n">optionally</span> <span class="n">attempting</span> <span class="n">to</span> <span class="n">write</span> <span class="n">a</span> <span class="n">snapshot</span><span class="p">)</span>
<span class="mi">2</span><span class="p">)</span> <span class="n">Try</span> <span class="n">to</span> <span class="nb">print</span> <span class="n">the</span> <span class="n">Self</span> <span class="n">stack</span>
<span class="mi">3</span><span class="p">)</span> <span class="n">Try</span> <span class="n">to</span> <span class="k">return</span> <span class="n">to</span> <span class="n">the</span> <span class="n">Self</span> <span class="n">prompt</span>
<span class="mi">4</span><span class="p">)</span> <span class="n">Force</span> <span class="n">a</span> <span class="n">core</span> <span class="n">dump</span>
<span class="n">Your</span> <span class="n">choice</span><span class="p">:</span>
</pre></div>
</div>
<p>The first two lines help the Self implementors locate the problem. Printing the Self stack may
provide more information about the problem but does not always work. Returning to the Self
prompt may be successful, but the system integrity may have been compromised as a result of the
error. The safest course is to attempt to write a snapshot (if there are unsaved changes), and then
check the integrity of the snapshot by executing the primitive <code class="docutils literal"><span class="pre">_Verify</span></code> after starting it. If there are
any error messages from the primitive, do not attempt to continue using the snapshot.</p>
<p>Since fatal errors usually arise from a bug in the virtual machine, please send the Self group a bug
report, and include a copy of the error message if possible. If the error is reproducible please describe
how to reproduce it (including a snapshot or source files may be helpful).</p>
<span class="target" id="index-8"></span><span class="target" id="index-9"></span><span class="target" id="index-10"></span><span class="target" id="index-11"></span><span class="target" id="index-12"></span><span class="target" id="index-13"></span><span class="target" id="index-14"></span><span class="target" id="index-15"></span><span class="target" id="index-16"></span><span class="target" id="index-17"></span><span class="target" id="index-18"></span><span class="target" id="index-19"></span><span class="target" id="index-20"></span><span class="target" id="index-21"></span><span class="target" id="index-22"></span><span class="target" id="index-23"></span><span class="target" id="index-24"></span><span class="target" id="index-25"></span><span class="target" id="index-26"></span><span class="target" id="index-27"></span><span class="target" id="index-28"></span><span class="target" id="index-29"></span><span class="target" id="index-30"></span><span class="target" id="index-31"></span></div>
<div class="section" id="the-initial-self-world">
<h2>8.12. The initial Self world</h2>
<p>The diagram on the following pages shows all objects in the “bare” Self world. In addition, literals
like integers, floats, and strings are conceptually part of the initial Self world; block and object
literals are created by the programmer as needed. All the objects in the system are created by adding
slots to these objects or by cloning them. <a class="reference internal" href="#tableobjinworld"><span class="std std-numref">Table 8.1</span></a> lists all the initial objects and provides a short
description for each. Reading in the world rearranges the structure of the “bare” Self world (see <a class="reference internal" href="selfwrld.xhtml"><span class="doc">The Self World</span></a>).</p>
<div class="figure" id="id4">
<span id="initialselfworld"></span><img alt="_images/Chapter_5_Figure_3.png" src="_images/Chapter_5_Figure_3.png" />
<p class="caption"><span class="caption-number">Fig. 8.1 </span><span class="caption-text">The initial Self world (part 1)</span></p>
</div>
<div class="figure" id="id5">
<img alt="_images/Chapter_5_Figure_4.png" src="_images/Chapter_5_Figure_4.png" style="width: 695.0px; height: 451.0px;" />
<p class="caption"><span class="caption-number">Fig. 8.2 </span><span class="caption-text">The initial Self world (part 2)</span></p>
</div>
<table border="1" class="colwidths-given docutils" id="id6">
<span id="tableobjinworld"></span><caption><span class="caption-number">Table 8.1 </span><span class="caption-text">Objects in the initial Self world</span></caption>
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Object</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">lobby</span></code></td>
<td>The center of the Self object hierarchy, and the context in which expressions typed in at the VM prompt, read in via <code class="docutils literal"><span class="pre">_RunScript</span></code>, or used as the initializers of slots, are evaluated.</td>
</tr>
</tbody>
</table>
<table border="1" class="colwidths-given docutils" id="id7">
<caption><span class="caption-number">Table 8.2 </span><span class="caption-text">Objects in the lobby</span></caption>
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Object</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">shell</span></code></td>
<td>After reading in the world, shell is the context in which expressions typed in at the prompt are evaluated.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">snapshotAction</span></code></td>
<td>An object with slot for the startup action (see <a class="reference internal" href="#system-triggered-messages">System-triggered messages</a>), <code class="docutils literal"><span class="pre">postRead</span></code>. This slot initially contains nil.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">systemObjects</span></code></td>
<td>This object contains slots containing the general system objects, including nil, true, false, and the prototypical vectors and mirrors.</td>
</tr>
</tbody>
</table>
<table border="1" class="colwidths-given docutils" id="id8">
<caption><span class="caption-number">Table 8.3 </span><span class="caption-text">Objects in systemObjects</span></caption>
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Object</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">nil</span></code></td>
<td>The initializer for slots that are not explicitly initialized. Indicates “not a useful object.”</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">true</span></code></td>
<td>Boolean <code class="docutils literal"><span class="pre">true</span></code>. Argument to and returned by some primitives.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">false</span></code></td>
<td>Boolean <code class="docutils literal"><span class="pre">false</span></code>. Argument to and returned by some primitives.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">vector</span></code></td>
<td>The prototype for (normal) vectors.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">byteVector</span></code></td>
<td>The prototype for byte vectors.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">proxy</span></code></td>
<td>The prototype for proxy objects.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">fctProxy</span></code></td>
<td>The prototype for fctProxy objects.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">vector</span> <span class="pre">parent</span></code></td>
<td>The object that vector inherits from. Since all object vectors will inherit from this object (because they are cloned from vector), this object will be the repository for shared behavior (a traits object) for vectors.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">byteVector</span> <span class="pre">parent</span></code></td>
<td>Similar to vector parent: the byteVector traits object.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">slotAnnotation</span></code></td>
<td>The default slot annotation object.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">objectAnnotation</span></code></td>
<td>The default object annotation object</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">profiler</span></code></td>
<td>The prototype for profilers.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">mirrors</span></code></td>
<td>See below.</td>
</tr>
</tbody>
</table>
<table border="1" class="colwidths-given docutils" id="id9">
<caption><span class="caption-number">Table 8.4 </span><span class="caption-text">Literals and their parents</span></caption>
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Literal</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">integers</span></code></td>
<td>Integers have one slot, a parent slot called parent. All integers have the same parent: see 0 parent, below.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">0</span> <span class="pre">parent</span></code></td>
<td>All integers share this parent, the integer traits object.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">floats</span></code></td>
<td>Floats have one slot, a parent slot called parent. All floats have the same parent: see <code class="docutils literal"><span class="pre">0.0</span> <span class="pre">parent</span></code>, below.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">0.0</span> <span class="pre">parent</span></code></td>
<td>All floats share this parent, the float traits object.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">canonical</span> <span class="pre">strings</span></code></td>
<td>In addition to a byte vector part, a canonical string has one slot, parent, a parent slot containing the same object for all canonical strings (see <code class="docutils literal"><span class="pre">’’</span> <span class="pre">parent</span></code> below).</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">''</span> <span class="pre">parent</span></code></td>
<td>All canonical strings share this parent, the string traits object.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">blocks</span></code></td>
<td>Blocks have two slots: <code class="docutils literal"><span class="pre">parent</span></code>, a parent slot containing the same object for all blocks (see <code class="docutils literal"><span class="pre">[</span> <span class="pre">]</span> <span class="pre">parent</span></code>, below), and <code class="docutils literal"><span class="pre">value</span></code> (or <code class="docutils literal"><span class="pre">value:</span></code>, or <code class="docutils literal"><span class="pre">value:With:</span></code>, etc., depending on the number of arguments the block takes) which contains the block’s deferred method.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">[</span> <span class="pre">]</span> <span class="pre">parent</span></code></td>
<td>All blocks share this parent, the block traits object.</td>
</tr>
</tbody>
</table>
<span class="target" id="index-35"></span><span class="target" id="index-36"></span><span class="target" id="index-37"></span><span class="target" id="index-38"></span><span class="target" id="index-39"></span><table border="1" class="colwidths-given docutils" id="id10">
<caption><span class="caption-number">Table 8.5 </span><span class="caption-text">Prototypical mirrors</span></caption>
<colgroup>
<col width="9%" />
<col width="91%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Mirror</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">smiMirror</span></code></td>
<td>Prototypical mirror on a small integer; the reflectee is 0.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">floatMirror</span></code></td>
<td>Prototypical mirror on a float; the reflectee is 0.0.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">stringMirror</span></code></td>
<td>Prototypical mirror on a canonical string; the reflectee is the empty canonical string (<code class="docutils literal"><span class="pre">’’</span></code>).</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">processMirror</span></code></td>
<td>Prototypical mirror on a process; the reflectee is the initial process.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">byteVectorMirror</span></code></td>
<td>Prototypical mirror on a byte vector; the reflectee is the prototypical byte vector.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">objVectorMirror</span></code></td>
<td>Prototypical mirror on object vectors; the reflectee is the prototypical object vector.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">assignmentMirror</span></code></td>
<td>Mirror on the assignment primitive; the actual reflectee is an empty object.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">mirrorMirror</span></code></td>
<td>Prototypical mirror on a mirror; the reflectee is <code class="docutils literal"><span class="pre">slotsMirror</span></code>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">slotsMirror</span></code></td>
<td>Prototypical mirror on a plain object without code; the reflectee is an empty object.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">blockMirror</span></code></td>
<td>Prototypical mirror on a block.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">methodMirror</span></code></td>
<td>Prototypical mirror on a normal method.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">blockMethodMirror</span></code></td>
<td>Prototypical mirror on a block method.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">methodActivationMirror</span></code></td>
<td>Prototypical mirror on a method activation.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">blockMethodActivationMirror</span></code></td>
<td>Prototypical mirror on a block activation.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">proxyMirror</span></code></td>
<td>Prototypical mirror on a proxy.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">fctProxyMirror</span></code></td>
<td>Prototypical mirror on a fctProxy.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">profilerMirror</span></code></td>
<td>Prototypical mirror on a profiler.</td>
</tr>
</tbody>
</table>
<p>All of the prototypical mirrors consist of one slot, a parent slot named parent. Each of
these parent slots points to an empty object (denoted in <a class="reference internal" href="#initialselfworld"><span class="std std-numref">Fig. 8.1</span></a> by “<code class="docutils literal"><span class="pre">(</span> <span class="pre">)</span></code>”).</p>
<span class="target" id="index-41"></span><span class="target" id="index-42"></span></div>
<div class="section" id="option-primitives">
<h2>8.13. Option Primitives</h2>
<p><strong>This section has not been updated to include all options present in Self 4.0.</strong></p>
<p>Option primitives control various aspects of the Self system and its inner workings. Many of
them are used to debug or instrument the Self system and are probably of little interest to users.
The options most useful for users are listed in <a class="reference internal" href="#tableoptionprimitives"><span class="std std-numref">Table 8.6</span></a>; other option primitives can be found in Appendix
<a class="reference internal" href="primitives.xhtml#pp-primitives"><span class="std std-ref">10.8</span></a> <a class="reference internal" href="primitives.xhtml"><span class="doc">Primitives</span></a>, and a list of all option primitives and their current settings can be printed with the
primitive <code class="docutils literal"><span class="pre">_PrintOptionPrimitives.</span></code></p>
<span class="target" id="index-44"></span><span class="target" id="index-45"></span><span class="target" id="index-46"></span><table border="1" class="docutils" id="id11">
<span id="tableoptionprimitives"></span><caption><span class="caption-number">Table 8.6 </span><span class="caption-text">Some useful option primitives</span></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal"><span class="pre">_PrintPeriod[:]</span></code></td>
<td>Print a period when reading a script file with <code class="docutils literal"><span class="pre">_RunScript</span></code>. Default: <code class="docutils literal"><span class="pre">false</span></code>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">_PrintScriptName[:]</span></code></td>
<td>Print the file name when reading a script file. Default: <code class="docutils literal"><span class="pre">false</span></code>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">_Spy[:]</span></code></td>
<td>Start the system monitor (see Appendix <a class="reference internal" href="monitor.xhtml#pp-the-system-monitor"><span class="std std-ref">10.7</span></a> for details). Default: <code class="docutils literal"><span class="pre">false</span></code>.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal"><span class="pre">_StackPrintLimit[:]</span></code></td>
<td>Controls the number of stack frames printed by <code class="docutils literal"><span class="pre">_PrintProcessStack</span></code>. Default: <code class="docutils literal"><span class="pre">20</span></code>.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal"><span class="pre">_DirPath[:]</span></code></td>
<td>The default directory path for script files.</td>
</tr>
</tbody>
</table>
<p>Each option primitive controls a variable within the virtual machine containing a boolean, integer,
or string (in fact, the option primitives can be thought of as “primitive variables”). Invoking the
version of the primitive that doesn’t take an argument <a class="footnote-reference" href="#f1" id="id1"><sup>1</sup></a> returns the current setting; invoking it with
an argument sets the variable to the new value and returns the old value.</p>
<p>Try running the system monitor with <code class="docutils literal"><span class="pre">_Spy:</span> <span class="pre">true</span></code>. The system monitor will continuously display
various information about the system’s activities and your memory usage.</p>
<span class="target" id="index-48"></span><span class="target" id="index-49"></span><span class="target" id="index-50"></span><span class="target" id="index-51"></span><span class="target" id="index-52"></span><span class="target" id="index-53"></span><span class="target" id="index-54"></span><span class="target" id="index-55"></span></div>
<div class="section" id="interfacing-with-other-languages">
<h2>8.14. Interfacing with other languages</h2>
<p>This chapter describes how to access objects and call routines that are written in other languages
than Self. We will refer to such entities as <em>foreign objects</em> and <em>foreign routines</em>. A typical use
would be to make a function found in a C library accessible in Self. Three steps are necessary to
accomplish this:</p>
<blockquote>
<div><ul class="simple">
<li>Write and compile a piece of “glue” code that specifies argument and result types for the foreign routine and how to convert between these types and Self objects.</li>
<li>Link the resulting object code to the Self virtual machine.</li>
<li>Create a function proxy object (actually a <code class="docutils literal"><span class="pre">foreignFct</span></code> object) that represents the routine in the Self world.</li>
</ul>
</div></blockquote>
<p>Each of these steps is described in detail in the following sections.</p>
<span class="target" id="index-57"></span><span class="target" id="index-58"></span><div class="section" id="proxy-and-fctproxy-objects">
<span id="index-59"></span><h3>8.14.1. <code class="docutils literal"><span class="pre">proxy</span></code> and <code class="docutils literal"><span class="pre">fctProxy</span></code> objects</h3>
<p>A foreign object is represented by a proxy object in the Self world. A <em>proxy</em> object is an object
that encapsulates a pointer to the foreign object it represents. In addition to the pointer to the foreign
object, the proxy object contains a type seal. A type seal is an immutable value that is assigned
to the proxy object, when it is created. The <em>type seal</em> is intended to capture type information about
the pointer encapsulated in the proxy. For example, proxies representing window objects should
have a different type seal than proxies representing event objects. By checking the type seal against
an expected value whenever a proxy is “opened”, many type errors can be caught. The last property
of proxy objects is that they can be <em>dead</em> or <em>live</em>. If an attempt is made to use the pointer in a dead
proxy object, an error results (<code class="docutils literal"><span class="pre">deadProxyError</span></code>). Proxy objects may be explicitly killed, by
sending the primitive message <code class="docutils literal"><span class="pre">_Kill</span></code> to them. Furthermore, they are automatically killed after
reading in a snapshot. This way problems with dangling references to foreign objects that were not
included in the snapshot are avoided.</p>
<p><code class="docutils literal"><span class="pre">fctProxy</span></code> objects are similar to proxy objects: they have a type seal and are either live or dead.
However, they represent a foreign routine, rather than a foreign object. A foreign routine can be invoked
by sending the primitive messages <code class="docutils literal"><span class="pre">_Call</span></code>, <code class="docutils literal"><span class="pre">_Call:{With:}</span></code>,
<code class="docutils literal"><span class="pre">_CallAndConvert{With:And:}</span></code> to the <code class="docutils literal"><span class="pre">fctProxy</span></code> representing it. Note that <code class="docutils literal"><span class="pre">fctProxy</span></code> objects
are low-level. Most, if not all, uses of foreign routines should use the interface provided by <code class="docutils literal"><span class="pre">foreignFct</span></code>
objects.</p>
<p>Proxies (and fctProxies) can be freely cloned. However a cloned proxy will be dead. A dead
proxy is revived when it is used by a foreign function to, e.g., return a pointer. The return value of
the foreign function together with a type seal is stored into the dead proxy, which is then revived
and returned as the result of the foreign routine call. The motivation for this somewhat complicated
approach is that there will be several different kinds of proxies in a typical Self system. Different
kinds of proxies may have different slots added, so rather than having the foreign routine figure out
which kind of proxy to clone for the result, the Self code calling the foreign routine must construct
and pass down an “empty” (dead) proxy to hold the result. This proxy is called a <em>result proxy</em>
and it is the last argument supplied to the foreign function.</p>
<span class="target" id="index-60"></span><span class="target" id="index-61"></span></div>
<div class="section" id="glue-code">
<span id="index-62"></span><h3>8.14.2. Glue code</h3>
<p>Glue code is responsible for the transition from Self to foreign routines. It forms wrappers around
foreign routines. There is one wrapper per foreign routine. A wrapper takes a number of arguments
of type <code class="docutils literal"><span class="pre">oop</span></code>, and returns an <code class="docutils literal"><span class="pre">oop</span></code> (<code class="docutils literal"><span class="pre">oop</span></code> is the C++ type for “reference to Self object”). When a
wrapper is executed, it performs the following steps:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Check that the arguments supplied have the correct types.</li>
<li>Convert the arguments from Self representation to the representation that the foreign routine needs.</li>
<li>Invoke the foreign routine on the converted arguments.</li>
<li>Convert the return value of the foreign routine to a Self object and return this as the Self level result.</li>
</ol>
</div></blockquote>
<p>To make it easier to write glue code, a special purpose language has been designed for this. The
result is that glue for a foreign routine will often consist of only a single line. The glue language is
implemented as a set of C++ preprocessor macros. Therefore, glue code is just a (rather peculiar)
kind of C++. Glue code can be in a file of its own, or – if it is glue for calling C++ routines – it can
be in the same file as the foreign routines, and compiled with them.</p>
<p>To make the definition of the glue language available, the file containing glue code must contain:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="c1"># include &quot;_glueDefs.c.incl&quot;</span>
</pre></div>
</div>
<p>The file “<code class="docutils literal"><span class="pre">_glueDefs.c.incl</span></code>” includes a bunch of C++ header files that contain all the definitions
necessary for the glue. Of the included files, “<code class="docutils literal"><span class="pre">glueDefs.h</span></code>” is probably the most interesting in this
context. It defines the glue language and also contains some comments explaining it.</p>
<p>Since different foreign languages have different type systems and calling conventions the glue language
is actually not a single language, but one for each supported foreign language. Presently C
and C++ are supported. See sections <a class="reference internal" href="#c-glue">C glue</a> and <a class="reference internal" href="#id2">C++ glue</a> for details.</p>
<span class="target" id="index-63"></span><span class="target" id="index-64"></span></div>
<div class="section" id="compiling-and-linking-glue-code">
<span id="index-65"></span><h3>8.14.3. Compiling and linking glue code</h3>
<p>Since glue code is a special form of C++ code, a C++ compiler is needed to translate it. The way
this is done may depend on the computer system and the available C++ compiler. The following
description applies to Sun SPARCstations using the GNU g++ compiler.</p>
<p>A specific example of how to compile glue code can be found in the directory containing the <em>toself</em>
demo (see <a class="reference internal" href="#a-complete-application-using-foreign-functions">A complete application using foreign functions</a> for further details). The makefile in that directory describes how to
translate a <code class="docutils literal"><span class="pre">.c</span></code> file containing glue into something that can be invoked from Self. This is a two
stage process: first the <code class="docutils literal"><span class="pre">.c</span></code> file is compiled into a <code class="docutils literal"><span class="pre">.o</span></code> file which is then linked (perhaps with other
<code class="docutils literal"><span class="pre">.o</span></code> files and libraries that the glue code depends on) into a <code class="docutils literal"><span class="pre">.so</span></code> file (a so-called dynamic library).
While the compilation is straightforward, several issues concerning the linking must be explained.</p>
<dl class="docutils">
<dt><strong>Linking</strong></dt>
<dd>Before a foreign routine can be called it must be linked to the Self virtual machine. The
linking can be done either statically, i.e. before Self is started, or dynamically, i.e. while Self is
running. The Self system employs both dynamic and static linking, but users should only use dynamic
linking, as static linking requires more understanding of the structure of the Virtual Machine.
The choice between dynamic and static linking involves a trade-off between safety and
flexibility as outlined in the following.</dd>
<dt><strong>Dynamic linking</strong></dt>
<dd>Dynamic linking has the advantage that it is done on demand, so only foreign routines that are actually
used in a particular session will be loaded and take up space. Debugging foreign routines is
also easier, especially if the dynamic linker supports unlinking. The main disadvantages with dynamic
linking is that more things can go wrong at run time. For example, if an object file containing
a foreign routine can not be found, a run time error occurs. The Sun OS dynamic linker, <code class="docutils literal"><span class="pre">ld.so</span></code>,
only handles dynamic libraries which explains why the second stage of glue translation is necessary.</dd>
<dt><strong>Static linking</strong></dt>
<dd>Static linking, the alternative that was not chosen for Self, has the advantage that it needs to be
done only once. The statically linked-in files will then be available for ever after. The main disadvantages
are that the linked-in files will always take up space whether used or not in a given Self
session, that the VM must be completely relinked every time new code is added, and that debugging
is harder because there is no way to unlink code with bugs in. For these reasons the following
examples all use dynamic linking.</dd>
</dl>
</div>
<div class="section" id="a-simple-glue-example-calling-a-c-function">
<span id="index-66"></span><h3>8.14.4. A simple glue example: calling a C function</h3>
<p>Suppose we have a C function that encrypts text strings in some fancy way. It takes two arguments,
a string to encrypt and a key, and returns a string which is the result of the encryption. To use this
function from Self, we write a line of C glue. Here is the entire file, “<code class="docutils literal"><span class="pre">encrypt.c</span></code>”, containing both
the encryption function and the glue:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/* Make glue available by including it. */
# include &quot;incls/_glueDefs.c.incl&quot;
/* Naive encryption function. */
char *encrypt(char *str, int key) {
    static char res[1000];
    int i;
    for (i = 0; str[i]; ++i)
        res[i] = str[i] + key;
    res[i] = ’\0’;
    return res;
}

/* Make glue expand to full functions, not just prototypes. */
# define WHAT_GLUE FUNCTIONS
    C_func_2(string,, encrypt, encrypt_glue,, string,, int,)
# undef WHAT_GLUE
</pre></div>
</div>
<p>A few words of explanation: the last three lines of this file contain the glue code. First defining
<code class="docutils literal"><span class="pre">WHAT_GLUE</span></code> to be <code class="docutils literal"><span class="pre">FUNCTIONS</span></code>, makes the following line expand into a full wrapper function (defining
<code class="docutils literal"><span class="pre">WHAT_GLUE</span></code> to be <code class="docutils literal"><span class="pre">PROTOTYPES</span></code> instead, will cause the <code class="docutils literal"><span class="pre">C_func_2</span></code> line to produce a function
prototype only). The line containing the macro <code class="docutils literal"><span class="pre">C_func_2</span></code> is the actual wrapper for <code class="docutils literal"><span class="pre">encrypt</span></code>.
The “2” designates that <code class="docutils literal"><span class="pre">encrypt</span></code> takes 2 arguments. The meaning of the arguments, from left to
right are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">string,</span></code>: specifies that encrypt returns a string argument.</li>
<li><code class="docutils literal"><span class="pre">encrypt</span></code>: name of function we are constructing wrapper for.</li>
<li><code class="docutils literal"><span class="pre">encrypt_glue</span></code>: name that we want the wrapper function to have.</li>
<li>An empty argument signifying that encrypt is not to be passed a failure handle (explained later).</li>
<li><code class="docutils literal"><span class="pre">string,</span></code>: specifies that the first argument to encrypt is a string.</li>
<li><code class="docutils literal"><span class="pre">int,</span></code>: specifies that the second argument to encrypt is an int.</li>
</ul>
</div></blockquote>
<p>Having written this file, we now prepare a makefile to compile and link it. To do this, we can extend
the makefile in <code class="docutils literal"><span class="pre">objects/glue/{sun4,svr4}</span></code> (depending on OS in use) and then run make.
This results in the shared library file <code class="docutils literal"><span class="pre">encrypt.so</span></code>. Finally, to try it out, we can type these commands
(at the Self prompt or in the UI):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>&gt; _AddSlotsIfAbsent: ( | encrypt | )
lobby

&gt; encrypt: ( foreignFct copyName: ’encrypt_glue’ Path: ’encrypt.so’ )
lobby

&gt; encrypt
&lt;C++ function(encrypt_glue)&gt;

&gt; encrypt value: ’Hello Self’ With: 3
’Khoor#Vhoi’

&gt; encrypt value: ’Khoor#Vhoi’ With: -3
’Hello Self’
</pre></div>
</div>
<p>Comparing the signature for the function encrypt with the arguments to the <code class="docutils literal"><span class="pre">C_func_2</span></code> macro it
is clear that there is a straightforward mapping between the two. One day we hope to find the time
to write a Self program that can parse a C or C++ header file and generate glue code corresponding
to the definitions in it. In the meantime, glue code must be handwritten.</p>
<span class="target" id="index-67"></span></div>
<div class="section" id="c-glue">
<span id="index-68"></span><h3>8.14.5. C glue</h3>
<p>C glue supports accessing C functions and data from Self. There are three main parts of C glue:</p>
<blockquote>
<div><ul class="simple">
<li>Calling functions.</li>
<li>Reading/assigning global variables.</li>
<li>Reading/assigning a component in a struct that is represented by a proxy object in Self.</li>
</ul>
</div></blockquote>
<p>In addition, C++ glue for creating objects can be used to create C structs (see section <a class="reference internal" href="#id2">C++ glue</a>). The
following sections describe each of these parts of C glue.</p>
<span class="target" id="index-69"></span><span class="target" id="index-70"></span></div>
<div class="section" id="calling-c-functions">
<span id="index-71"></span><h3>8.14.6. Calling C functions</h3>
<p>The macro <code class="docutils literal"><span class="pre">C_func_N</span></code> where N is 0, 1, 2, ... is used to “glue in” a C function. The number N denotes
the number of arguments that should be given <em>at the Self level</em>, when calling the function. This
number may be different from the number of arguments that the C function takes since, e.g., some
argument conversions (see below) produce two C arguments from one Self object. Here is the
general syntax for <code class="docutils literal"><span class="pre">C_func_N</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">C_func_N</span><span class="p">(</span><span class="n">res_cnv</span><span class="p">,</span><span class="n">res_aux</span><span class="p">,</span> <span class="n">fexp</span><span class="p">,</span> <span class="n">gfname</span><span class="p">,</span> <span class="n">fail_opt</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span> <span class="o">...</span> <span class="n">cN</span><span class="p">,</span><span class="n">aN</span><span class="p">)</span>
</pre></div>
</div>
<p>Compare this with the glue that was used in the encrypt example in section <a class="reference internal" href="#a-simple-glue-example-calling-a-c-function">A simple glue example: calling a C function</a>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">C_func_2</span><span class="p">(</span><span class="n">string</span><span class="p">,,</span> <span class="n">encrypt</span><span class="p">,</span> <span class="n">encrypt_glue</span><span class="p">,,</span> <span class="n">string</span><span class="p">,,</span> <span class="nb">int</span><span class="p">,)</span>
</pre></div>
</div>
<p>The meaning of each argument to <code class="docutils literal"><span class="pre">C_func_N</span></code> is as follows:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">res_cnv,res_aux</span></code>: these two arguments form a “conversion pair” that specifies how the result that the function returns is converted to a Self object. In the <code class="docutils literal"><span class="pre">encrypt</span></code> example, where the function returns a null terminated string, <code class="docutils literal"><span class="pre">res_cnv</span></code> has the value <code class="docutils literal"><span class="pre">string</span></code>, and <code class="docutils literal"><span class="pre">res_aux</span></code> is empty. <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a> lists all the possible values for the <code class="docutils literal"><span class="pre">res_cnv,res_aux</span> <span class="pre">pair</span></code>.</li>
<li><code class="docutils literal"><span class="pre">fexp</span></code> is a C expression which evaluates to the function that is being glued in. In the simplest case, such as in the <code class="docutils literal"><span class="pre">encrypt</span></code> example, the expression is the name of a function, but in general it may be any C expression, involving function pointers etc., which in a global context evaluates to a function.</li>
<li><code class="docutils literal"><span class="pre">gfname</span></code>: the name of the function which the <code class="docutils literal"><span class="pre">C_func_N</span></code> macro expands into. In the <code class="docutils literal"><span class="pre">encrypt</span></code> example, the convention of appending <code class="docutils literal"><span class="pre">_glue</span></code> to the C function’s name was used. When accessing a glued-in function from Self, the value of <code class="docutils literal"><span class="pre">gfname</span></code> is the name that must be used.</li>
<li><code class="docutils literal"><span class="pre">fail_opt</span></code>: there are two possible values for this argument. It can be empty (as in the example) or it can be <code class="docutils literal"><span class="pre">fail</span></code>. In the latter case, the C function being called is passed an additional argument that will be the last argument and have type <code class="docutils literal"><span class="pre">“void</span> <span class="pre">*”</span></code>. Using this argument, the C function may abort its execution and raise an exception. The result is that the “IfFail block” in Self will be invoked.</li>
<li><code class="docutils literal"><span class="pre">ci,ai</span></code>: each of these pairs describes how to convert a Self level argument to one or more C level arguments. For example, in the glue for <code class="docutils literal"><span class="pre">encrypt</span></code>, <code class="docutils literal"><span class="pre">c0</span></code>,``a0`` specifies that the first argument to <code class="docutils literal"><span class="pre">encrypt</span></code> is a string. Likewise <code class="docutils literal"><span class="pre">c1</span></code>,``a1`` specifies that the second argument is an integer. Note that in both these cases, the a-part of the conversion is empty. <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a> lists all the possible values for the <code class="docutils literal"><span class="pre">ci</span></code>,``ai`` pair.</li>
</ul>
</div></blockquote>
<p><em>Handling failures</em>. Here is a slight modification of the encryption example to illustrate how the C function can raise an exception that causes the “IfFail block” to be invoked at the Self level:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>/* Make glue available by including it. */
# include &quot;incls/_glueDefs.c.incl&quot;
/* Naive encryption function. */
char *encrypt(char *str, int key, void *FH) {
    static char res[1000];
    int i;
    if (key == 0) {
            failure(FH, &quot;key == 0 is identity map&quot;);
            return NULL;
    }
    for (i = 0; str[i]; i++)
            res[i] = str[i] + key;
    res[i] = ’\0’;
    return res;
}
/* Make glue expand to full functions, not just prototypes. */
# define WHAT_GLUE FUNCTIONS
    C_func_2(string,, encrypt, encrypt_glue, fail, string,, int,)
# undef WHAT_GLUE
</pre></div>
</div>
<p>Observe that the <code class="docutils literal"><span class="pre">fail_opt</span></code> argument now has the value <code class="docutils literal"><span class="pre">fail</span></code> and that the <code class="docutils literal"><span class="pre">encrypt</span></code> function
raises an exception, using <code class="docutils literal"><span class="pre">failure</span></code>, if the key is 0. There are two ways to raise exceptions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="n">void</span> <span class="n">failure</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">FH</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">msg</span><span class="p">);</span>
<span class="n">extern</span> <span class="s2">&quot;C&quot;</span> <span class="n">void</span> <span class="n">unix_failure</span><span class="p">(</span><span class="n">void</span> <span class="o">*</span><span class="n">FH</span><span class="p">,</span> <span class="nb">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>In both cases, the <code class="docutils literal"><span class="pre">FH</span></code> argument is the “failure handle” that was passed by the <code class="docutils literal"><span class="pre">C_func_N</span></code> macro.
The second argument to <code class="docutils literal"><span class="pre">failure</span></code> is a string. It will be passed to the “IfFail block” in Self.
<code class="docutils literal"><span class="pre">unix_failure</span></code> takes an optional integer as its second argument. If this integer has the value -1,
or is missing, the value of <code class="docutils literal"><span class="pre">errno</span></code> is used instead. The integer is interpreted as a UNIX error number,
from which a corresponding string is constructed. The string is then, as for <code class="docutils literal"><span class="pre">failure</span></code>, passed
to the “IfFail block” at the call site in Self.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">After calling <code class="docutils literal"><span class="pre">failure</span></code> or <code class="docutils literal"><span class="pre">unix_failure</span></code> a normal <code class="docutils literal"><span class="pre">return</span></code> must be done. The value returned (in the example <code class="docutils literal"><span class="pre">NULL</span></code>) is ignored.</p>
</div>
<span class="target" id="index-72"></span></div>
<div class="section" id="reading-and-assigning-global-variables">
<span id="index-73"></span><h3>8.14.7. Reading and assigning global variables</h3>
<p>Reading the value of a global variable is done using the <code class="docutils literal"><span class="pre">C_get_var</span></code> macro. Assigning a value to
a global variable is done using <code class="docutils literal"><span class="pre">C_set_var</span></code>. Both macros expand into a C++ function that converts
between Self and C representation, and reads or assigns the variable. Here is the general syntax:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">C_get_var</span><span class="p">(</span><span class="n">cnvt_res</span><span class="p">,</span><span class="n">aux_res</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">gfname</span><span class="p">)</span>
<span class="n">C_set_var</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">expr_c0</span><span class="p">,</span><span class="n">expr_a0</span><span class="p">,</span> <span class="n">gfname</span><span class="p">)</span>
</pre></div>
</div>
<p>A concrete example is reading the value of the variable <code class="docutils literal"><span class="pre">errno</span></code>, which can be done using:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">C_get_var</span><span class="p">(</span><span class="nb">int</span><span class="p">,,</span> <span class="n">errno</span><span class="p">,</span> <span class="n">get_errno_glue</span><span class="p">)</span>
</pre></div>
</div>
<p>The meaning of the each argument is:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">cnvt_res</span></code>,``aux_res``: how to convert the value of the global variable that is being read to a Self object. In the <code class="docutils literal"><span class="pre">errno</span></code> example, <code class="docutils literal"><span class="pre">cnvt_res</span></code> is <code class="docutils literal"><span class="pre">int</span></code> and <code class="docutils literal"><span class="pre">aux_res</span></code> is empty, since the type of <code class="docutils literal"><span class="pre">errno</span></code> is <code class="docutils literal"><span class="pre">int</span></code>. The <code class="docutils literal"><span class="pre">cnvt_res</span></code>,``aux_res`` can be any one of the result conversions found in <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a>.</li>
<li><code class="docutils literal"><span class="pre">expr</span></code> is the variable whose value is being read. In the <code class="docutils literal"><span class="pre">errno</span></code> example, it is simply <code class="docutils literal"><span class="pre">errno</span></code>, but in general, it may actually be any expression that is valid in a global context, even an expression involving function calls.</li>
<li><code class="docutils literal"><span class="pre">gfname</span></code>: the name of the C++ function that <code class="docutils literal"><span class="pre">C_get_var</span></code> or <code class="docutils literal"><span class="pre">C_set_var</span></code> expands into.</li>
<li><code class="docutils literal"><span class="pre">var</span></code> is the name of a global variable that a value is assigned to. In general, <code class="docutils literal"><span class="pre">var</span></code>, may be any expression that in a global context evaluates to an l-value.</li>
<li><code class="docutils literal"><span class="pre">expr_c0</span></code>,``expr_a0``: when assigning to a variable, the value it is assigned is obtained by converting a Self object to a C value. The <code class="docutils literal"><span class="pre">expr_c0</span></code>,``expr_a0`` pair, which can be any one of the argument conversions listed in <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a>, specifies how to do this conversion.</li>
</ul>
</div></blockquote>
<span class="target" id="index-74"></span><span class="target" id="index-75"></span></div>
<div class="section" id="reading-and-assigning-struct-components">
<span id="index-76"></span><h3>8.14.8. Reading and assigning struct components</h3>
<p>Reading the value of a struct component or assigning a value to it is similar to doing the same operations
on a global variable. The difference is that the struct must somehow be specified. This is
taken care of by the macros <code class="docutils literal"><span class="pre">C_get_comp</span></code> and <code class="docutils literal"><span class="pre">C_set_comp</span></code>. The general syntax is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">C_get_comp</span><span class="p">(</span><span class="n">cnvt_res</span><span class="p">,</span><span class="n">aux_res</span><span class="p">,</span> <span class="n">cnvt_strc</span><span class="p">,</span><span class="n">aux_strc</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">gfname</span><span class="p">)</span>
<span class="n">C_set_comp</span><span class="p">(</span><span class="n">cnvt_strc</span><span class="p">,</span><span class="n">aux_strc</span><span class="p">,</span> <span class="n">comp</span><span class="p">,</span> <span class="n">expr_c0</span><span class="p">,</span><span class="n">expr_a0</span><span class="p">,</span> <span class="n">gfname</span><span class="p">)</span>
</pre></div>
</div>
<p>Here is an example, assigning to the sin_port field of a struct sockaddr_in (this struct is defined
in <code class="docutils literal"><span class="pre">/usr/include/netinet/in.h</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">sockaddr_in</span> <span class="p">{</span>
    <span class="n">short</span>           <span class="n">sin_family</span><span class="p">;</span>
    <span class="n">u_short</span>         <span class="n">sin_port</span><span class="p">;</span>
    <span class="n">struct</span> <span class="n">in_addr</span>  <span class="n">sin_addr</span><span class="p">;</span>
    <span class="n">char</span>            <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The struct is represented by a proxy object:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">char</span> <span class="o">*</span><span class="n">socks</span> <span class="o">=</span> <span class="s2">&quot;type seal for sockaddr_in proxies&quot;</span><span class="p">;</span>
<span class="n">C_set_comp</span><span class="p">(</span><span class="n">proxy</span><span class="p">,(</span><span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">,</span><span class="n">socks</span><span class="p">),</span> <span class="o">.</span><span class="n">sin_port</span><span class="p">,</span> <span class="n">short</span><span class="p">,,</span><span class="n">set_sin_port_glue</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">sockaddr_in</span></code> example defines a function, <code class="docutils literal"><span class="pre">set_sin_port_glue</span></code>, which can be called from
Self. The function takes two arguments, the first being a proxy representing a <code class="docutils literal"><span class="pre">sockaddr_in</span></code>
struct, the second being a short integer. After converting types, <code class="docutils literal"><span class="pre">set_sin_port_glue</span></code> performs
the assignment:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">*</span><span class="n">first_converted_arg</span><span class="p">)</span><span class="o">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">second_converted_arg</span><span class="o">.</span>
</pre></div>
</div>
<p>In general the meaning of the <code class="docutils literal"><span class="pre">C_get_comp</span></code> and <code class="docutils literal"><span class="pre">C_set_comp</span></code> arguments is:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">cnvt_res</span></code>, <code class="docutils literal"><span class="pre">aux_res</span></code>: how to convert the value of the component that is being read to a
Self object. Any of the result conversions found in <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a> may be applied.</li>
<li><code class="docutils literal"><span class="pre">cnvt_strc</span></code>, <code class="docutils literal"><span class="pre">aux_strc</span></code>: the conversion that is applied to produce a struct upon which the
operation is performed. In the <code class="docutils literal"><span class="pre">sin_port</span></code> example, this conversion is a proxy conversion,
implying that in Self, the struct whose <code class="docutils literal"><span class="pre">sin_port</span></code> component is assigned is represented by
a proxy object. In general, any of the argument conversions from <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a> that results in a
pointer, may be used.</li>
<li><code class="docutils literal"><span class="pre">comp</span></code> is the name of the component to be read or assigned. In the sin_port example, this
name is <code class="docutils literal"><span class="pre">“.sin_port”</span></code>. Note that it includes a “.”. This, e.g., allows handling pointers to
int’s by pretending that it is a pointer to a struct and operating on a component with an
empty name.</li>
<li><code class="docutils literal"><span class="pre">gfname</span></code>: the name of the C++ function that <code class="docutils literal"><span class="pre">C_get_comp</span></code> or <code class="docutils literal"><span class="pre">C_set_comp</span></code> expands into.</li>
<li><code class="docutils literal"><span class="pre">expr_co</span></code>, <code class="docutils literal"><span class="pre">expr_a0</span></code>: when assigning to a component, the value it is assigned is obtained by
converting a Self object to a C value. The <code class="docutils literal"><span class="pre">expr_co</span></code>, <code class="docutils literal"><span class="pre">expr_a0</span></code> pair, which can be any one
of the argument conversions listed in <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a>, specifies how to do this conversion.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id2">
<h3>8.14.9. C++ glue</h3>
<p>Since C++ is a superset of C, all of C glue can be used with C++. In addition, C++ glue provides
support for:</p>
<blockquote>
<div><ul class="simple">
<li>Constructing objects using the new operator.</li>
<li>Deleting objects using the delete operator.</li>
<li>Calling member functions on objects.</li>
</ul>
</div></blockquote>
<p>Each of these parts will be explained in the following sections.</p>
<span class="target" id="index-78"></span></div>
<div class="section" id="constructing-objects">
<span id="index-79"></span><h3>8.14.10. Constructing objects</h3>
<p>In C++, objects are constructed using the new operator. Constructors may take arguments. The
macros <code class="docutils literal"><span class="pre">CC_new_N</span></code> where N is a small integer, support calling constructors with or without arguments.
Calling a constructor is similar to calling a function, so for additional explanation, please
refer to section <a class="reference internal" href="#calling-c-functions">Calling C functions</a>. Here is the general syntax for constructing objects using C++ glue:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">CC_new_N</span><span class="p">(</span><span class="n">cnvt_res</span><span class="p">,</span><span class="n">aux_res</span><span class="p">,</span> <span class="n">class</span><span class="p">,</span> <span class="n">gfname</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span> <span class="o">...</span> <span class="n">cN</span><span class="p">,</span><span class="n">aN</span><span class="p">)</span>
</pre></div>
</div>
<p>For example, to construct a <code class="docutils literal"><span class="pre">sockaddr_in</span></code> object, the following glue statement could be used:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">CC_new_0</span><span class="p">(</span><span class="n">proxy</span><span class="p">,(</span><span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">,</span><span class="n">socks</span><span class="p">),</span> <span class="n">sockaddr_in</span><span class="p">,</span> <span class="n">new_sockaddr_in</span><span class="p">)</span>
</pre></div>
</div>
<p>The meanings of the <code class="docutils literal"><span class="pre">CC_new_N</span></code> arguments are as follows:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">cnvt_res</span></code>, <code class="docutils literal"><span class="pre">aux_res:</span></code> the result of calling the constructor is an object pointer. The result
conversion pair <code class="docutils literal"><span class="pre">cnvt_res</span></code>, <code class="docutils literal"><span class="pre">aux_res</span></code> (see <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a>), specifies how this pointer is converted
to a Self object before being returned. In the <code class="docutils literal"><span class="pre">sockaddr</span></code> example, the proxy result conversion
is used.</li>
<li><code class="docutils literal"><span class="pre">class</span></code> is the name of the class (or struct) that is being instantiated.</li>
<li><code class="docutils literal"><span class="pre">gfname</span></code>: the name of the C++ function that the <code class="docutils literal"><span class="pre">CC_new_N</span></code> macro expands into.</li>
<li><code class="docutils literal"><span class="pre">ci</span></code>, <code class="docutils literal"><span class="pre">ai</span></code>: if the constructor takes arguments, these arguments must be converted from Self
representation to C++ representation. The arguments conversion pairs <code class="docutils literal"><span class="pre">ci</span></code>, <code class="docutils literal"><span class="pre">ai</span></code> specify how
each argument is converted. See <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a> for a description of all argument conversions. In
the sockaddr example, there are no arguments.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="deleting-objects">
<h3>8.14.11. Deleting objects</h3>
<p>C++ objects can have destructors that are executed when the objects are deleted. To ensure that the
destructor is called properly, the <code class="docutils literal"><span class="pre">delete</span></code> operator must know the type of the object being deleted.
This is ensured by using the <code class="docutils literal"><span class="pre">CC_delete</span></code> macro, which has the following form:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">CC_delete</span><span class="p">(</span><span class="n">cnvt_obj</span><span class="p">,</span><span class="n">aux_obj</span><span class="p">,</span> <span class="n">gfname</span><span class="p">)</span>
</pre></div>
</div>
<p>For example, to delete <code class="docutils literal"><span class="pre">sockaddr_in</span></code> objects (constructed as in the previous section), the
<code class="docutils literal"><span class="pre">CC_delete</span></code> macro should be used in this manner:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">CC_delete</span><span class="p">(</span><span class="n">proxy</span><span class="p">,(</span><span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">,</span><span class="n">socks</span><span class="p">),</span> <span class="n">delete_sockaddr_in</span><span class="p">)</span>
</pre></div>
</div>
<p>In general, the meaning of the arguments given to <code class="docutils literal"><span class="pre">CC_delete</span></code> is:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">cnvt_obj,aux_obj</span></code>: this pair can be any of the argument conversions found in <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a>
that produces a pointer to the object that will be deleted.</li>
<li><code class="docutils literal"><span class="pre">gfname</span></code>: the name of the C++ function that this invocation of <code class="docutils literal"><span class="pre">CC_delete</span></code> expands into.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="calling-member-functions">
<h3>8.14.12. Calling member functions</h3>
<p><a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a> lists all the available argument conversions. Each row represents one conversion, with the
first two columns designating the conversion pair. The third column lists the types of Self objects
that the conversion pair accepts. The fourth column lists the C types that it produces. The fifth column
lists the kind of errors that can occur during the conversion. Finally, the sixth column contains
references to numbered notes. The notes are found in the paragraphs following the table.</p>
<p>Calling member functions is similar to calling “plain” functions, so please also refer to section
<a class="reference internal" href="#calling-c-functions">Calling C functions</a>. The difference is that an additional object must be specified: the object upon which the
member function is invoked (the receiver in Self terms). Calling a member function is accomplished
using one of the macros:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">CC_mber_N</span><span class="p">(</span><span class="n">cnvt_res</span><span class="p">,</span><span class="n">aux_res</span><span class="p">,</span> <span class="n">cnvt_rec</span><span class="p">,</span><span class="n">aux_rec</span><span class="p">,</span> <span class="n">mname</span><span class="p">,</span> <span class="n">gfname</span><span class="p">,</span>
          <span class="n">fail_opt</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">cN</span><span class="p">,</span><span class="n">aN</span><span class="p">)</span>
</pre></div>
</div>
<p>For example here is how to call the member function zock on a <code class="docutils literal"><span class="pre">sockaddr_in</span></code> object given by a
proxy:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">CC_mber_0</span><span class="p">(</span><span class="nb">bool</span><span class="p">,,</span> <span class="n">proxy</span><span class="p">,(</span><span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">,</span><span class="n">socks</span><span class="p">),</span> <span class="n">zock</span><span class="p">,</span> <span class="n">zock_glue</span><span class="p">,)</span>
</pre></div>
</div>
<p>The arguments to <code class="docutils literal"><span class="pre">CC_mber_N</span></code> are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">cnvt_res</span></code>, <code class="docutils literal"><span class="pre">aux_res</span></code>: this pair, which can be any of the result conversions from <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a>,
specifies how to convert the result of the member function before returning it to Self. For
example, the zock member function returns a boolean.</li>
<li><code class="docutils literal"><span class="pre">cnvt_rec</span></code>, <code class="docutils literal"><span class="pre">aux_rec</span></code>: the object on which the member function is invoked. Often this will
be a proxy conversion as in the <code class="docutils literal"><span class="pre">zock</span></code> example.</li>
<li><code class="docutils literal"><span class="pre">mname</span></code> is the name of the member function. In general, it may be any expression, such that
<code class="docutils literal"><span class="pre">receiver-&gt;mname</span></code> evaluates to a function.</li>
<li><code class="docutils literal"><span class="pre">gfname</span></code> is the name of the C++ function that the <code class="docutils literal"><span class="pre">CC_mber_N</span></code> macro expands into.</li>
<li><code class="docutils literal"><span class="pre">fail_opt</span></code>: whether or not to pass a failure handle to the member function (refer to section
<a class="reference internal" href="#calling-c-functions">Calling C functions</a> for details).</li>
<li><code class="docutils literal"><span class="pre">ci</span></code>, <code class="docutils literal"><span class="pre">ai</span></code>: these are argument conversion pairs specifying how to obtain the arguments for the
member function. Any conversion pair found in <a class="reference internal" href="#tableargumentconversions"><span class="std std-numref">Table 8.7</span></a> may be used.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="conversion-pairs">
<span id="index-80"></span><h3>8.14.13. Conversion pairs</h3>
<p>A major function of glue code is to convert between Self objects and C/C++ values. This conversion
is guarded by so-called conversion pairs. A <em>conversion pair</em> is a pair of arguments given to a
glue macro. It handles converting one or at most a few types of objects/values. There are different
conversion pairs for converting from Self objects to C/C++ values (called argument conversion
pairs) and for converting from C/C++ values to Self objects (called result conversion pairs).</p>
<span class="target" id="index-81"></span></div>
<div class="section" id="argument-conversions-from-self-to-c-c">
<span id="index-82"></span><h3>8.14.14. Argument conversions – from Self to C/C++</h3>
<p>An argument conversion is given a Self object and performs these actions to produce a corresponding
C or C++ value:</p>
<blockquote>
<div><ul class="simple">
<li>check that the Self object it has been given is among the allowed types. If not, report
<code class="docutils literal"><span class="pre">badTypeError</span></code> (invoke the failure block (if present) with the argument <code class="docutils literal"><span class="pre">’badTypeError’</span></code>).</li>
<li>check that the object can be converted to a C/C++ value without overflow or any other error.
If not, report the relevant error.</li>
<li>do the conversion, i.e., construct the C/C++ value corresponding to the given Self object.</li>
</ul>
</div></blockquote>
<span class="target" id="index-83"></span><span class="target" id="index-84"></span><span class="target" id="index-85"></span><span class="target" id="index-86"></span><table border="1" class="docutils" id="id12">
<span id="tableargumentconversions"></span><caption><span class="caption-number">Table 8.7 </span><span class="caption-text">Argument conversions - from Self to C/C++</span></caption>
<colgroup>
<col width="11%" />
<col width="14%" />
<col width="21%" />
<col width="11%" />
<col width="39%" />
<col width="6%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Conversion</th>
<th class="head">Second part</th>
<th class="head">Self type</th>
<th class="head">C/C++ type</th>
<th class="head">Errors</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>bool</td>
<td>&#160;</td>
<td>boolean</td>
<td>int (0 or 1)</td>
<td>badTypeError</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>char</td>
<td>&#160;</td>
<td>smallInt</td>
<td>char</td>
<td>badTypeError overflowError</td>
<td>1</td>
</tr>
<tr class="row-even"><td>signed_char</td>
<td>&#160;</td>
<td>smallInt</td>
<td>signed char</td>
<td>badTypeError overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>unsigned_char</td>
<td>&#160;</td>
<td>smallInt</td>
<td>unsigned char</td>
<td>badSignError badTypeError overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>short</td>
<td>&#160;</td>
<td>smallInt</td>
<td>short</td>
<td>badTypeError overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>signed_short</td>
<td>&#160;</td>
<td>smallInt</td>
<td>signed short</td>
<td>badTypeError overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>unsigned_short</td>
<td>&#160;</td>
<td>smallInt</td>
<td>unsigned short</td>
<td>badSignError badTypeError overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>int</td>
<td>&#160;</td>
<td>smallInt</td>
<td>int</td>
<td>badTypeError</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>signed_int</td>
<td>&#160;</td>
<td>smallInt</td>
<td>signed int</td>
<td>badTypeError</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>unsigned_int</td>
<td>&#160;</td>
<td>smallInt</td>
<td>unsigned int</td>
<td>badSignError badTypeError</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>long</td>
<td>&#160;</td>
<td>smallInt</td>
<td>long</td>
<td>badTypeError</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>signed_long</td>
<td>&#160;</td>
<td>smallInt</td>
<td>signed long</td>
<td>badTypeError</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>unsigned_long</td>
<td>&#160;</td>
<td>smallInt</td>
<td>unsigned long</td>
<td>badSignError</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>smi</td>
<td>&#160;</td>
<td>smallInt</td>
<td>smi</td>
<td>badTypeError</td>
<td>2</td>
</tr>
<tr class="row-even"><td>unsigned_smi</td>
<td>&#160;</td>
<td>smallInt</td>
<td>smi</td>
<td>badSignError badTypeError</td>
<td>2</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="14%" />
<col width="21%" />
<col width="11%" />
<col width="39%" />
<col width="6%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Conversion</th>
<th class="head">Second part</th>
<th class="head">Self type</th>
<th class="head">C/C++ type</th>
<th class="head">Errors</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>float</td>
<td>&#160;</td>
<td>float</td>
<td>float</td>
<td>badTypeError</td>
<td>3</td>
</tr>
<tr class="row-odd"><td>double</td>
<td>&#160;</td>
<td>float</td>
<td>double</td>
<td>badTypeError</td>
<td>3</td>
</tr>
<tr class="row-even"><td>long_double</td>
<td>&#160;</td>
<td>float</td>
<td>long double</td>
<td>badTypeError</td>
<td>3</td>
</tr>
<tr class="row-odd"><td>bv</td>
<td>ptr_type</td>
<td>byte vector</td>
<td>ptr_type</td>
<td>badTypeError</td>
<td>4</td>
</tr>
<tr class="row-even"><td>bv_len</td>
<td>ptr_type</td>
<td>byte vector</td>
<td>ptr_type, int</td>
<td>badSizeError badTypeError</td>
<td>4, 5</td>
</tr>
<tr class="row-odd"><td>bv_null</td>
<td>ptr_type</td>
<td>byte vector/0</td>
<td>ptr_type</td>
<td>badTypeError</td>
<td>4, 6</td>
</tr>
<tr class="row-even"><td>bv_len_null</td>
<td>ptr_type</td>
<td>byte vector/0</td>
<td>ptr_type, int</td>
<td>badSizeError badTypeError</td>
<td>4, 5, 6</td>
</tr>
<tr class="row-odd"><td>cbv</td>
<td>ptr_type</td>
<td>byte vector</td>
<td>ptr_type</td>
<td>badTypeError</td>
<td>7</td>
</tr>
<tr class="row-even"><td>cbv_len</td>
<td>ptr_type</td>
<td>byte vector</td>
<td>ptr_type, int</td>
<td>badSizeError badTypeError</td>
<td>7</td>
</tr>
<tr class="row-odd"><td>cbv_null</td>
<td>ptr_type</td>
<td>byte vector/0</td>
<td>ptr_type</td>
<td>badTypeError</td>
<td>7</td>
</tr>
<tr class="row-even"><td>cbv_len_null</td>
<td>ptr_type</td>
<td>byte vector/0</td>
<td>ptr_type, int</td>
<td>badSizeError badTypeError</td>
<td>7</td>
</tr>
<tr class="row-odd"><td>string</td>
<td>&#160;</td>
<td>byte vector</td>
<td>char *</td>
<td>badTypeError nullCharError</td>
<td>8</td>
</tr>
<tr class="row-even"><td>string_len</td>
<td>&#160;</td>
<td>byte vector</td>
<td>char *, int</td>
<td>badTypeError nullCharError</td>
<td>5, 8</td>
</tr>
<tr class="row-odd"><td>string_null</td>
<td>&#160;</td>
<td>byte vector/0</td>
<td>char *</td>
<td>badTypeError nullCharError</td>
<td>6, 8</td>
</tr>
<tr class="row-even"><td>string_len_null</td>
<td>&#160;</td>
<td>byte vector/0</td>
<td>char *, int</td>
<td>badTypeError nullCharError</td>
<td>5, 6, 8</td>
</tr>
<tr class="row-odd"><td>proxy</td>
<td>(ptr_type, type_seal)</td>
<td>proxy</td>
<td>ptr_type, != NULL</td>
<td>badTypeError badTypeSealError, deadProxyError,nullPointerError</td>
<td>9</td>
</tr>
<tr class="row-even"><td>proxy_null</td>
<td>(ptr_type, type_seal)</td>
<td>proxy</td>
<td>ptr_type</td>
<td>badTypeError badTypeSealError deadProxyError</td>
<td>9</td>
</tr>
<tr class="row-odd"><td>any_oop</td>
<td>&#160;</td>
<td>any object</td>
<td>oop</td>
<td>&#160;</td>
<td>10</td>
</tr>
<tr class="row-even"><td>oop</td>
<td>oop subtype</td>
<td>corresponding object</td>
<td>oop (subtype)</td>
<td>badTypeError</td>
<td>11</td>
</tr>
<tr class="row-odd"><td>any</td>
<td>C/C++ type</td>
<td>int/float/proxy/byte-vector, int</td>
<td>int/float/ptr/ptr</td>
<td>badIndexError badTypeError deadProxyError</td>
<td>12</td>
</tr>
</tbody>
</table>
<div class="section" id="notes">
<h4>8.14.14.1. Notes</h4>
<blockquote>
<div><ol class="arabic simple">
<li>The C type <code class="docutils literal"><span class="pre">char</span></code> has a system dependent range. Either 0..255 or -128..127.</li>
<li>The type <code class="docutils literal"><span class="pre">smi</span></code> is used internally in the virtual machine (a 30 bit integer).</li>
<li>Precision may be lost in the conversion.</li>
<li>The second part of the conversion is a C pointer type. The address of the first byte in the byte
vector, cast to this pointer type, is passed to the foreign routine. It is the responsibility of
the foreign routine not to go past the end of the byte vector. The foreign routine should not retain
pointers into the byte vector after the call has terminated. Note: canonical strings can not be passed
through a bv conversion (<code class="docutils literal"><span class="pre">badTypeError</span></code> will result). This is to ensure that they are not accidentally
modified by a foreign function.</li>
<li>This conversion passes two values to the foreign routine: a pointer to the first byte in the byte
vector, and an integer which is the length of the byte vector divided by <code class="docutils literal"><span class="pre">sizeof(*ptr_type)</span></code>. If
the size of the byte vector is not a multiple of <code class="docutils literal"><span class="pre">sizeof(*ptr_type)</span></code>, <code class="docutils literal"><span class="pre">badSizeError</span></code> results.</li>
<li>In addition to accepting a byte vector, this conversion accepts the integer 0, in which case a <code class="docutils literal"><span class="pre">NULL</span></code>
pointer is passed to the foreign routine.</li>
<li>The <code class="docutils literal"><span class="pre">cbv</span></code> conversions are like the bv conversions except that canonical strings are allowed as actual
arguments. A <code class="docutils literal"><span class="pre">cbv</span></code> conversion should only be used if it is guaranteed that the foreign routine
does not modify the bytes it gets a pointer to.</li>
<li>All the string conversions take an incoming byte vector, copy the bytes part, add a trailing null
char, and pass a pointer to this copy to the foreign routine. After the call has terminated, the copy
is discarded. If the byte vector contains a null char, <code class="docutils literal"><span class="pre">nullCharError</span></code> results.</li>
<li>The <code class="docutils literal"><span class="pre">type_seal</span></code> is an <code class="docutils literal"><span class="pre">int</span></code> or <code class="docutils literal"><span class="pre">char</span></code> * expression that is tested against the type seal value in the
proxy. If the two are different, <code class="docutils literal"><span class="pre">badTypeSealError</span></code> results. The special value <code class="docutils literal"><span class="pre">ANY_SEAL</span></code> will
match the type seal in any proxy. Note that the <code class="docutils literal"><span class="pre">proxy</span></code> conversion will fail with <code class="docutils literal"><span class="pre">nullPointerError</span></code>
if the proxy object it is given encapsulates a NULL pointer.</li>
<li>The <code class="docutils literal"><span class="pre">any_oop</span></code> conversion is an escape: it passes the Self object unchanged to the foreign routine.</li>
<li>The <code class="docutils literal"><span class="pre">oop</span></code> conversion is mainly intended for internal use. The second argument is the name of
an oop subtype. After checking that the incoming argument points to an instance of the subtype,
the pointer is cast to the subtype.</li>
<li>The <code class="docutils literal"><span class="pre">any</span></code> conversion is different from all other conversions in that it expects two incoming
Self objects. The actions of the conversion depends on the type of the first object in the following
way. If the first object is an integer, the second argument must also be an integer; the two integers
are converted to C <code class="docutils literal"><span class="pre">int</span></code>’s, the second is shifted 16 bits to the left and they are or’ed together to produce
the result. If the first object is a float, it is converted to a C <code class="docutils literal"><span class="pre">float</span></code> and the second object is
ignored. If the first object is a proxy, the result is the pointer represented by the proxy, and the second
argument is ignored. If the first object is a byte vector, the second object must be an integer
which is interpreted as an index into the byte vector; the result is a pointer to the indexed byte.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="result-conversions-from-c-c-to-self">
<span id="index-88"></span><h3>8.14.15. Result conversions - from C/C++ to Self</h3>
<p>A result conversion is given a C or C++ value of a certain type and performs these actions to produce
a corresponding Self object:</p>
<blockquote>
<div><ul class="simple">
<li>check that the C/C++ value can be converted to a Self object with no overflow or other error
occurring. If not, report the error.</li>
<li>do the conversion, i.e., construct the Self object corresponding to the given C/C++ value.</li>
</ul>
</div></blockquote>
<p><a class="reference internal" href="#tableresultconversions"><span class="std std-numref">Table 8.8</span></a> lists all the available result conversions. Each row represents one conversion, with the first
two columns designating the conversion pair. The third column lists the type of C or C++ value that
the conversion pair accepts. The fourth column lists the type of Self object the conversion produces.
The fifth column lists the kind of errors that can occur during the conversion. Finally, the sixth
column contains references to numbered notes. The notes are found in the paragraphs following
the table.</p>
<table border="1" class="docutils" id="id13">
<span id="tableresultconversions"></span><caption><span class="caption-number">Table 8.8 </span><span class="caption-text">Result conversions - from C/C++ to Self</span></caption>
<colgroup>
<col width="19%" />
<col width="28%" />
<col width="14%" />
<col width="14%" />
<col width="16%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Conversion</th>
<th class="head">Second part</th>
<th class="head">C/C++ type</th>
<th class="head">Self type</th>
<th class="head">Errors</th>
<th class="head">Notes</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>void</td>
<td>&#160;</td>
<td>void</td>
<td>smallInt (0)</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>bool</td>
<td>&#160;</td>
<td>int</td>
<td>boolean</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>char</td>
<td>&#160;</td>
<td>char</td>
<td>smallInt</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>signed_char</td>
<td>&#160;</td>
<td>signed char</td>
<td>smallInt</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>unsigned_char</td>
<td>&#160;</td>
<td>unsigned char</td>
<td>smallInt</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>short</td>
<td>&#160;</td>
<td>short</td>
<td>smallInt</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>signed_short</td>
<td>&#160;</td>
<td>signed short</td>
<td>smallInt</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>unsigned_short</td>
<td>&#160;</td>
<td>unsigned short</td>
<td>smallInt</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>int</td>
<td>&#160;</td>
<td>int</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>signed_int</td>
<td>&#160;</td>
<td>signed int</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>unsigned_int</td>
<td>&#160;</td>
<td>unsigned int</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>long</td>
<td>&#160;</td>
<td>long</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>signed_long</td>
<td>&#160;</td>
<td>signed long</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>unsigned_long</td>
<td>&#160;</td>
<td>unsigned long</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>smi</td>
<td>&#160;</td>
<td>smi</td>
<td>smallInt</td>
<td>overflowError</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>int_or_errno</td>
<td>n</td>
<td>int</td>
<td>int</td>
<td>a UNIX error</td>
<td>1</td>
</tr>
<tr class="row-even"><td>float</td>
<td>&#160;</td>
<td>float</td>
<td>float</td>
<td>&#160;</td>
<td>2</td>
</tr>
<tr class="row-odd"><td>double</td>
<td>&#160;</td>
<td>double</td>
<td>float</td>
<td>&#160;</td>
<td>2</td>
</tr>
<tr class="row-even"><td>long_double</td>
<td>&#160;</td>
<td>long double</td>
<td>float</td>
<td>&#160;</td>
<td>2</td>
</tr>
<tr class="row-odd"><td>string</td>
<td>&#160;</td>
<td>char *</td>
<td>byte vector</td>
<td>nullPointerError</td>
<td>3</td>
</tr>
<tr class="row-even"><td>proxy</td>
<td>(ptr_type, type_seal)</td>
<td>ptr_type</td>
<td>proxy</td>
<td>nullPointerError</td>
<td>3, 4, 8</td>
</tr>
<tr class="row-odd"><td>proxy_null</td>
<td>(ptr_type, type_seal)</td>
<td>ptr_type</td>
<td>proxy</td>
<td>&#160;</td>
<td>4, 8</td>
</tr>
<tr class="row-even"><td>proxy_or_errno</td>
<td>(ptr_type, type_seal, n)</td>
<td>ptr_type</td>
<td>proxy</td>
<td>a UNIX error</td>
<td>4, 5, 8</td>
</tr>
<tr class="row-odd"><td>fct_proxy</td>
<td>(ptr_type, type_seal, arg_count)</td>
<td>ptr_type</td>
<td>fctProxy</td>
<td>nullPointerError</td>
<td>3, 6, 8</td>
</tr>
<tr class="row-even"><td>fct_proxy_null</td>
<td>(ptr_type, type_seal, arg_count)</td>
<td>ptr_type</td>
<td>fctProxy</td>
<td>&#160;</td>
<td>6, 8</td>
</tr>
<tr class="row-odd"><td>oop</td>
<td>&#160;</td>
<td>oop</td>
<td>corresponding
object</td>
<td>&#160;</td>
<td>7, 8</td>
</tr>
</tbody>
</table>
<div class="section" id="id3">
<h4>8.14.15.1. Notes</h4>
<blockquote>
<div><ol class="arabic simple">
<li>This conversion returns an integer value, unless the integer has the value n (the second part of
the conversion; often -1). If the integer is n, the conversion interprets the return value as a UNIX
error indicator. It then constructs a string describing the error (by looking at <code class="docutils literal"><span class="pre">errno</span></code>) and invokes
the “IfFail block” with this string.</li>
<li>Precision may be lost.</li>
<li>This conversion fails with <code class="docutils literal"><span class="pre">nullPointerError</span></code> if attempting to convert a NULL pointer.</li>
<li>The <code class="docutils literal"><span class="pre">ptr_type</span></code> is the C/C++ type of the pointer. The <code class="docutils literal"><span class="pre">type_seal</span></code> is an expression of type int
or <code class="docutils literal"><span class="pre">char</span> <span class="pre">*</span></code>.The conversion constructs a new proxy object, stores the C/C++ pointer in it and sets
its type seal to be the value of <code class="docutils literal"><span class="pre">type_seal</span></code>.</li>
<li>If the pointer is <code class="docutils literal"><span class="pre">n</span></code> (often <code class="docutils literal"><span class="pre">n</span></code> is <code class="docutils literal"><span class="pre">NULL</span></code>), the conversion fails with a UNIX error, similar to the way
<code class="docutils literal"><span class="pre">int_or_errno</span></code> may fail.</li>
<li>The <code class="docutils literal"><span class="pre">fct_proxy</span></code>, <code class="docutils literal"><span class="pre">fct_proxy_null</span></code> and <code class="docutils literal"><span class="pre">fct_proxy_or_errno</span></code> conversions are similar to
the corresponding proxy conversions. The difference is that they produce a <code class="docutils literal"><span class="pre">fctProxy</span></code> object rather
than a proxy object. Also, their second part is a triple rather than a pair. The extra component
specifies how many arguments the function takes, if called. The special keyword <code class="docutils literal"><span class="pre">unknownNoOfArgs</span></code>
or any nonnegative integer expression can be used here.</li>
<li>This conversion is an escape: it passes the C value unchanged to Self. It is an error to use it if
the C value is not an <code class="docutils literal"><span class="pre">oop</span></code>.</li>
<li>The <code class="docutils literal"><span class="pre">proxy</span></code> (<code class="docutils literal"><span class="pre">fctProxy</span></code>) object that is returned by these conversions is <em>not</em> being created by the
glue code. Rather a <code class="docutils literal"><span class="pre">proxy</span></code> (<code class="docutils literal"><span class="pre">fctProxy</span></code>) must be passed down from the Self level. This <code class="docutils literal"><span class="pre">proxy</span></code>
(<code class="docutils literal"><span class="pre">fctProxy</span></code>), a <em>result proxy</em>, will then be side effected by the glue: the value that the foreign function
returns will be stored in the result proxy together with the requested type seal. It is required
that the result proxy is dead when passed down (else a <code class="docutils literal"><span class="pre">liveProxyError</span></code> results). After being
side-effected and returned, the result proxy is live. The result proxy is the last argument of the
function that the glue macro expands to.</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="a-complete-application-using-foreign-functions">
<h3>8.14.16. A complete application using foreign functions</h3>
<p>This section gives a description of a complete application which uses foreign functions. The aim is
to present a realistic and complete example of how foreign functions may be used. The complete
source for the example is found in the directory <code class="docutils literal"><span class="pre">objects/applications/serverDemo</span></code> in the
Self distribution.</p>
<p>The example used is an application that allows Self expressions to be easily evaluated by non-
Self processes. Having this, it then becomes possible to start Self processes from a UNIX
prompt (shell) or to specify pipe lines in which some of the processes are Self processes. For example
in</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">proto</span><span class="o">%</span> <span class="n">cat</span> <span class="n">someFile</span> <span class="o">|</span> <span class="n">tokenize</span> <span class="o">|</span> <span class="n">sort</span> <span class="o">-</span><span class="n">r</span> <span class="o">|</span> <span class="n">capitalize</span> <span class="o">|</span> <span class="n">tee</span> <span class="n">lst</span>
</pre></div>
</div>
<p>it may be the case that the filters tokenize and capitalize perform most of their work in Self.
Likewise, the command</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">proto</span><span class="o">%</span> <span class="n">mail</span>
</pre></div>
</div>
<p>may invoke some fancy mail reader written in Self rather than the standard UNIX mail reader.</p>
<p>To see how the above can be accomplished, please refer to <a class="reference internal" href="#figsingleunixproc"><span class="std std-numref">Fig. 8.3</span></a> below. The left side of the figure
shows the external view of a typical UNIX process. It has two files: stdin and stdout (for simplicity
we ignore stderr). Stdin is often connected to the keyboard so that characters typed here can
be read from the file stdin. Likewise, stdout is typically connected to the console so that the process
can display output by writing it to the file stdout. Stdin and stdout can also be connected to “regular”
files, if the process was started with redirection. The right side of <a class="reference internal" href="#figsingleunixproc"><span class="std std-numref">Fig. 8.3</span></a> shows a two stage
pipe line. Here stdout of the first process is connected to stdin of the second process.</p>
<div class="figure align-left" id="id14">
<span id="figsingleunixproc"></span><img alt="_images/Chapter_5_Figure_5.png" src="_images/Chapter_5_Figure_5.png" style="width: 718.2px; height: 91.0px;" />
<p class="caption"><span class="caption-number">Fig. 8.3 </span><span class="caption-text">A single UNIX process and an pipe line.</span></p>
</div>
<p><a class="reference internal" href="#figsingleunixproc"><span class="std std-numref">Fig. 8.3</span></a> illustrates a simple trick that in many situations allows Self processes to behave as if they
are full-fledged UNIX processes. A Self process is represented by a “real” UNIX process which
transparently communicates with the Self process over a pair of connected sockets. The communication
is bidirectional: input to the UNIX process is relayed to the Self process over the socket
connection, and output produced by the Self process is sent over the same socket connection to
the UNIX process which relays it to stdout. The right part of <a class="reference internal" href="#figsingleunixproc"><span class="std std-numref">Fig. 8.3</span></a> shows how the UNIX/Self
process pair can fit seamlessly into a pipe line.</p>
<div class="figure" id="id15">
<img alt="_images/Chapter_5_Figure_6.png" src="_images/Chapter_5_Figure_6.png" />
<p class="caption"><span class="caption-number">Fig. 8.4 </span><span class="caption-text">A Self process and how it fits into a pipe line.</span></p>
</div>
<p>Source code that facilitates setting up such UNIX/Self process pairs is included in the Self distribution.
The source consists of two parts: one being a Self program (called <em>server</em>), the other being
a C++ program (called <em>toself</em>). When the server is started, it creates a socket, binds a name to it
and then listens for connections on it. <code class="docutils literal"><span class="pre">toself</span></code> establishes connections to the server program. The
first line that is transmitted when a connection has been set up goes from <code class="docutils literal"><span class="pre">toself</span></code> to the server. The
line contains a Self expression. Upon receiving it, the server forks a new process to evaluate the
expression in the context of the lobby augmented with a slot, stdio, that contains a <code class="docutils literal"><span class="pre">unixFile</span></code>-like
object that represents the socket connection. When the forked process terminates, the socket connection
is shut down. The <code class="docutils literal"><span class="pre">toself</span></code> UNIX process then terminates.</p>
<p>The Self expression that forms the Self process is specified on the command line when <code class="docutils literal"><span class="pre">toself</span></code>
is started. For example, if the server has been started, the following can be typed at the UNIX
prompt:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">proto</span><span class="o">%</span> <span class="n">toself</span> <span class="n">stdio</span> <span class="n">writeLine</span><span class="p">:</span> <span class="mi">5</span> <span class="n">factorial</span> <span class="n">printString</span>
<span class="mi">120</span>

<span class="n">proto</span><span class="o">%</span> <span class="n">echo</span> <span class="n">something</span> <span class="o">|</span> <span class="n">toself</span> <span class="n">capitalize</span><span class="p">:</span> <span class="n">stdio</span>
<span class="n">SOMETHING</span>

<span class="n">proto</span><span class="o">%</span> <span class="n">toself</span> <span class="n">capitalize</span><span class="p">:</span> <span class="n">stdio</span>
<span class="n">Write</span> <span class="n">some</span> <span class="n">text</span> <span class="n">that</span> <span class="n">goes</span> <span class="n">to</span> <span class="n">stdin</span> <span class="n">of</span> <span class="n">the</span> <span class="n">toself</span> <span class="n">program</span>
<span class="n">WRITE</span> <span class="n">SOME</span> <span class="n">TEXT</span> <span class="n">THAT</span> <span class="n">GOES</span> <span class="n">TO</span> <span class="n">STDIN</span> <span class="n">OF</span> <span class="n">THE</span> <span class="n">TOSelf</span> <span class="n">PROGRAM</span>
<span class="n">More</span> <span class="n">text</span>
<span class="n">MORE</span> <span class="n">TEXT</span>
<span class="o">^</span><span class="n">D</span>

<span class="n">proto</span><span class="o">%</span>
</pre></div>
</div>
<p>If you want to try out these examples, locate the files <code class="docutils literal"><span class="pre">server.self</span></code>, <code class="docutils literal"><span class="pre">socks.so</span></code> and <code class="docutils literal"><span class="pre">toself</span></code>. The
path name of the file <code class="docutils literal"><span class="pre">socks.so</span></code> is hardwired in the file <code class="docutils literal"><span class="pre">server.self</span></code> so please make sure that it
has been set correctly for your system. Then file in the world and type [<code class="docutils literal"><span class="pre">server</span> <span class="pre">start</span></code>] <code class="docutils literal"><span class="pre">fork</span></code> at
the Self prompt. Now you can go back to the UNIX prompt and try out the examples shown
above.</p>
</div>
<div class="section" id="outline-of-toself">
<h3>8.14.17. Outline of <code class="docutils literal"><span class="pre">toself</span></code></h3>
<p><code class="docutils literal"><span class="pre">toself</span></code> is a small C++ program found in the file <code class="docutils literal"><span class="pre">toself.c</span></code>. It operates in the three phases outlined
above:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Try to connect to a well-known port number on a given machine (the function <code class="docutils literal"><span class="pre">establishConnection</span></code>
does this).</li>
<li>Send the command line arguments over the connection established in 1 (the <code class="docutils literal"><span class="pre">safeWrite</span></code>
call in <code class="docutils literal"><span class="pre">main</span></code> does this).</li>
<li>While there is more input and the Self process has not shut down the socket connection,
relay from stdin to the socket connection and from the socket connection to stdout (the function
<code class="docutils literal"><span class="pre">relay</span></code> does this).</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="outline-of-server">
<h3>8.14.18. Outline of server</h3>
<p>The server is a Self program. It is found in the file <code class="docutils literal"><span class="pre">server.self</span></code>. When the server is started, the
following happens:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Create a socket, bind a name to it and start listening.</li>
<li><dl class="first docutils">
<dt>Loop: accept a connection and fork a new process (both step 1 and 2 are performed by the method <code class="docutils literal"><span class="pre">server</span> <span class="pre">start</span></code>). The forked process executes the method <code class="docutils literal"><span class="pre">server</span> <span class="pre">handleRequest</span></code> which:</dt>
<dd><ol class="first last loweralpha">
<li>Reads a line from the connection.</li>
<li>Sets up a context with a slot <code class="docutils literal"><span class="pre">stdio</span></code> referring to the connection.</li>
<li>Evaluates the line read in step (a) in this context.</li>
<li>Closes the connection.</li>
</ol>
</dd>
</dl>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="foreign-functions-and-glue-needed-to-implement-server">
<h3>8.14.19. Foreign functions and glue needed to implement server</h3>
<p>The server program needs to do a number of UNIX calls to create sockets and bind names to them
etc. The calls needed are <code class="docutils literal"><span class="pre">socket</span></code>, <code class="docutils literal"><span class="pre">bind</span></code>, <code class="docutils literal"><span class="pre">listen</span></code>, <code class="docutils literal"><span class="pre">accept</span></code> and <code class="docutils literal"><span class="pre">shutdown</span></code>. The first three of these
are only called in a fixed sequence, so to make things easier, a small C++ function
<code class="docutils literal"><span class="pre">socket_bind_listen</span></code>, that bundles them up in the right sequence, has been written. The <code class="docutils literal"><span class="pre">accept</span></code>
function is more general than what is needed for this application, so a wrapper function,
<code class="docutils literal"><span class="pre">simple_accept</span></code>, has been written. The result is that the server needs to call only three foreign
functions: <code class="docutils literal"><span class="pre">socket_bind_listen</span></code>, <code class="docutils literal"><span class="pre">simple_accept</span></code> and <code class="docutils literal"><span class="pre">shutdown</span></code>. Glue for these three functions
and the source for the first two is found in the file <code class="docutils literal"><span class="pre">socks.c</span></code>. This file is compiled and linked
using the <code class="docutils literal"><span class="pre">Makefile</span></code>. The result is a shared object file, <code class="docutils literal"><span class="pre">socks.so</span></code>.</p>
</div>
<div class="section" id="use-of-foreign-functions-in-server-self">
<h3>8.14.20. Use of foreign functions in server.self</h3>
<p>The server program is implemented using <code class="docutils literal"><span class="pre">foreignFct</span></code> objects. There is only a few lines of code
directly involved in setting this up. First the <code class="docutils literal"><span class="pre">foreignFct</span></code> prototype is cloned to obtain a “local
prototype”, called <code class="docutils literal"><span class="pre">socksFct</span></code>, which contains the path for the <code class="docutils literal"><span class="pre">socks.so</span></code> file. <code class="docutils literal"><span class="pre">socksFct</span></code> is then
cloned each time a <code class="docutils literal"><span class="pre">foreignFct</span></code> object for a function defined in <code class="docutils literal"><span class="pre">socks.so</span></code> is needed. For example,
in <code class="docutils literal"><span class="pre">traits</span> <span class="pre">socket</span></code>, the following method is found:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>copyPort: portNumber = ( &quot;Create a socket, do bind, then listen.&quot;
        | sbl = socksFct copyName: ’socket_bind_listen_glue’. |
        sbl value: portNumber With: deadCopy.
    ).
</pre></div>
</div>
<p>This method copies a <code class="docutils literal"><span class="pre">socket</span></code> object and returns the copy. The local slot <code class="docutils literal"><span class="pre">sbl</span></code> is initialized to a
<code class="docutils literal"><span class="pre">foreignFct</span></code> object. The body of the method simply sends <code class="docutils literal"><span class="pre">value:With:</span></code> to the <code class="docutils literal"><span class="pre">foreignFct</span></code>
object. The first argument is the port number to request for the socket, the second argument is a
<code class="docutils literal"><span class="pre">deadCopy</span></code> of self (socket objects are proxies and <code class="docutils literal"><span class="pre">socket_bind_listen</span></code> returns a proxy, so it
must be passed a dead proxy to revive and store the result in; see section <a class="reference internal" href="#proxy-and-fctproxy-objects">Proxy and fctProxy objects</a>).</p>
<p>There are only three uses of <code class="docutils literal"><span class="pre">foreignFct</span></code> objects in the server and in all three cases, the <code class="docutils literal"><span class="pre">foreignFct</span></code>
object is encapsulated in a method as illustrated above.</p>
<p>In general the design of <code class="docutils literal"><span class="pre">foreignFct</span></code> objects has been aimed at making the use of them light
weight. When cloning them, it is only necessary to specify the minimal information: the name of
the foreign function. They can be encapsulated in a method thus localizing the impact of redesigns.
The complications of dynamic loading and linking are handled automatically, as is the recovery of
dead <code class="docutils literal"><span class="pre">fctProxies</span></code>.</p>
<p class="rubric" id="index-89">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>The bracketed colon indicates that the argument is optional (i.e., there are two versions of the primitive, one taking an argument and one not taking an argument). The bracket is not part of the primitive name. See text for details.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
  </body>
</html>